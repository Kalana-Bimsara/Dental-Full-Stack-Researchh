name: Full-stack CI/CD with Docker Compose

on:
  push:
    branches:
      - main
    # don't retrigger the workflow when we commit the metrics file
    paths-ignore:
      - 'metrics/**'
  workflow_dispatch:

jobs:
  multiarch-build-publish-to-docker-hub:
    name: Build & Publish (amd64+arm64) to Docker Hub
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    # Expose START_TS so the deploy job can read it
    outputs:
      START_TS: ${{ steps.lt_start.outputs.START_TS }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: backend
            context: app/backend
            file: app/backend/Dockerfile.prod.yml
            repo_suffix: dental-backend
          - name: frontend
            context: app/frontend
            file: app/frontend/Dockerfile.nginx.prod.yml
            repo_suffix: dental-frontend 
            
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # DORA start = time the commit landed on main (merge commit time)
      - name: Capture DORA start timestamp (merge commit time on main)
        id: lt_start
        run: echo "START_TS=$(git show -s --format=%cI $GITHUB_SHA)" >> "$GITHUB_OUTPUT"

      - name: Set up QEMU (cross-arch)
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_ACCESS_KEY }}

      - name: Prepare tags
        run: |
          USER_LC=$(echo "${{ secrets.DOCKER_USERNAME }}" | tr '[:upper:]' '[:lower:]')
          SHORT_SHA=${GITHUB_SHA::12}
          SAFE_REF=$(echo "$GITHUB_REF_NAME" | tr '[:upper:]' '[:lower:]' | tr -c 'a-z0-9_.-' '-')
          echo "USER_LC=$USER_LC" >> $GITHUB_ENV
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "SAFE_REF=$SAFE_REF" >> $GITHUB_ENV

      - name: Build & push ${{ matrix.name }}
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.file }}
          platforms: linux/arm64
          push: true
          tags: |
            ${{ env.USER_LC }}/${{ matrix.repo_suffix }}:latest
            ${{ env.USER_LC }}/${{ matrix.repo_suffix }}:${{ env.SHORT_SHA }}
            ${{ env.USER_LC }}/${{ matrix.repo_suffix }}:${{ env.SAFE_REF }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # clean the environment
      - name: Cleanup containers/images/volumes
        if: always()
        run: |
          docker ps -aq | xargs -r docker rm -f
          docker rmi -f myorg/backend:ci || true
          docker image prune -af || true
          docker network prune -f || true
          docker volume prune -f || true
          docker system prune -af --volumes || true

  deploy-ec2-Testing-environment:
    name: Deploy New images to Testing environment EC2 via SSH
    needs: multiarch-build-publish-to-docker-hub
    runs-on: ubuntu-latest
    # allow committing the metrics CSV back to the repo
    permissions:
      contents: write

    steps:
      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_TEST_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          script_stop: true
          envs: |
            DOCKER_USER,DOCKER_TOKEN,BACKEND_IMAGE,FRONTEND_IMAGE,MONGO_URI,STRIPE_SECRET_KEY
          command_timeout: 30m
          script: |
            # ----- pull newest images -----
            sudo docker pull "${{ secrets.DOCKER_USERNAME }}/dental-backend:latest"
            sudo docker pull "${{ secrets.DOCKER_USERNAME }}/dental-frontend:latest"

            # ----- stop & remove old containers -----
            sudo docker rm -f backend || true
            sudo docker rm -f frontend || true

            # ----- run backend (port 9000) -----
            sudo docker run -d --name backend \
              --restart unless-stopped \
              -e NODE_ENV=testing \
              -e BACKEND_PORT=9000 \
              -e FRONT_END_PORT=80 \
              -e HOST="http://${{ secrets.EC2_TEST_HOST }}" \
              -e MONGO_URI="${{ secrets.MONGO_URI }}" \
              -e STRIPE_SECRET_KEY="${{ secrets.STRIPE_SECRET_KEY }}" \
              -p 9000:9000 \
              "${{ secrets.DOCKER_USERNAME }}/dental-backend:latest"

            # ----- run frontend (container listens on 8080; expose public 80) -----
            sudo docker run -d --name frontend \
              --restart unless-stopped \
              -e NODE_ENV=testing \
              -e FRONT_END_PORT=80 \
              -e VITE_BACKEND_PORT="9000" \
              -e VITE_FRONTEND_URL="http://${{ secrets.EC2_TEST_HOST }}" \
              -e VITE_HOST="http://${{ secrets.EC2_TEST_HOST }}" \
              -p 80:80 \
              "${{ secrets.DOCKER_USERNAME }}/dental-frontend:latest"

            # ----- health check -----
            sleep 3
            sudo docker ps

      # DORA end = right after deploy completes
      - name: Stamp end time (UTC)
        id: lt_end
        run: echo "END_TS=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> "$GITHUB_OUTPUT"

      # Compute Lead Time and save (Sri Lanka time)
      - name: Compute Lead Time and save (Sri Lanka time)
        run: |
          python - << 'PY'
          from datetime import datetime, timezone
          from zoneinfo import ZoneInfo
          import os, csv

          start_raw = os.environ["START_TS"]
          end_raw   = os.environ["END_TS"]

          def to_dt(ts: str) -> datetime:
            ts = ts.replace("Z", "+00:00")
            return datetime.fromisoformat(ts)

          s = to_dt(start_raw)
          e = to_dt(end_raw)

          lead_minutes = (e - s).total_seconds() / 60.0

          SL = ZoneInfo("Asia/Colombo")
          s_local = s.astimezone(SL)
          e_local = e.astimezone(SL)

          print(f"LeadTimeMinutes={lead_minutes:.2f}")

          rows = [
            ["repo","sha","start_ts","end_ts","lead_time_min"],
            [os.environ["GITHUB_REPOSITORY"], os.environ["GITHUB_SHA"],
             s_local.isoformat(), e_local.isoformat(), f"{lead_minutes:.2f}"]
          ]
          with open("lead_time.csv","w", newline="") as f:
            csv.writer(f).writerows(rows)
          PY
        env:
          START_TS: ${{ needs.multiarch-build-publish-to-docker-hub.outputs.START_TS }}
          END_TS: ${{ steps.lt_end.outputs.END_TS }}

      # Keep the artifact (optional)
      - name: Upload Lead Time artifact
        uses: actions/upload-artifact@v4
        with:
          name: lead-time
          path: lead_time.csv
          if-no-files-found: warn

      # --- Save each run as its own CSV file in the repo ---
      - name: Checkout repo (for metrics commit)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          path: repo  # checkout into subfolder so lead_time.csv in CWD isn't lost

      - name: Write unique metrics file
        env:
          RUN_ID: ${{ github.run_id }}
          RUN_ATTEMPT: ${{ github.run_attempt }}
          SHA: ${{ github.sha }}
        run: |
          mkdir -p repo/metrics/lead_time_runs
          SHORT_SHA=${SHA::12}
          OUT="repo/metrics/lead_time_runs/lead_time_${SHORT_SHA}_run${RUN_ID}_a${RUN_ATTEMPT}.csv"
          cp lead_time.csv "$OUT"
          echo "Saved $OUT"

      - name: Commit metrics file (skip CI)
        working-directory: repo
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add metrics/lead_time_runs/*.csv
          git commit -m "[metrics] add lead time file per run [skip ci]" || echo "No changes to commit"
          git pull --rebase origin main
          git push origin main

  Run-All-Testing:
    name: Run Test Cases on Testing environment
    runs-on: ubuntu-latest
    needs: [deploy-ec2-Testing-environment,  multiarch-build-publish-to-docker-hub ]
    permissions:
      contents: read

    steps:
      - name: Clone functional tests repo
        run: git clone https://github.com/Kalana-Bimsara/functional_tests.git
      - name: Run Full Suite
        working-directory: functional_tests
        env:
          MONGODB_URI: ${{ secrets.TEST_MONGODB_URI }}
          MONGODB_DBNAME: "test"
        run: |
          docker compose run --rm tests-full

      - name: Upload Full Suite Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: full-suite-report-${{ github.run_id }}
          path: functional_tests/test-results/full

  update-risk:
    needs: Run-All-Testing
    if: always()                      
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Update risk-data.json
        run: |
          node risk/scripts/update-failure-history.js

      - name: Commit updated risk file
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add risk/risk-data.json
          git commit -m "Update risk scores"
          git push
     
      
  Run-rbt-Testing:
    name: Run RBT Test Cases on Testing environment
    runs-on: ubuntu-latest
    needs: [deploy-ec2-Testing-environment,  multiarch-build-publish-to-docker-hub]
    permissions:
      contents: read

    steps:
      - name: Clone functional tests repo
        run: git clone https://github.com/Kalana-Bimsara/functional_tests.git
     

      - name: Run RBT Suite
        working-directory: functional_tests

        env:
          MONGODB_URI: ${{ secrets.TEST_MONGODB_URI }}
          MONGODB_DBNAME: "test"
        run: docker compose run --rm tests-rbt

      - name: Upload RBT Reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: rbt-report-${{ github.run_id }}
          path: functional_tests/test-results/rbt

        
  deploy-ec2-prod-environment-a:
    name: Deploy New images to Production-a environment EC2 via SSH
    needs: [Run-All-Testing]
    runs-on: ubuntu-latest
    # allow committing the metrics CSV back to the repo
    permissions:
      contents: write

    steps:
      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_PROD_01_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          script_stop: true
          envs: |
            DOCKER_USER,DOCKER_TOKEN,BACKEND_IMAGE,FRONTEND_IMAGE,MONGO_URI,STRIPE_SECRET_KEY
          command_timeout: 30m
          script: |
            # ----- pull newest images -----
            sudo docker pull "${{ secrets.DOCKER_USERNAME }}/dental-backend:latest"
            sudo docker pull "${{ secrets.DOCKER_USERNAME }}/dental-frontend:latest"

            # ----- stop & remove old containers -----
            sudo docker rm -f backend || true
            sudo docker rm -f frontend || true

            # # ----- run backend (port 9000) -----
            # sudo docker run -d --name backend \
            #   --restart unless-stopped \
            #   -e NODE_ENV=production \
            #   -e BACKEND_PORT=9000 \
            #   -e MONGO_URI="${{ secrets.MONGO_URI }}" \
            #   -e STRIPE_SECRET_KEY="${{ secrets.STRIPE_SECRET_KEY }}" \
            #   -p 9000:9000 \
            #   "${{ secrets.DOCKER_USERNAME }}/dental-backend:latest"

            # # ----- run frontend (container listens on 8080; expose public 80) -----
            # sudo docker run -d --name frontend \
            #   --restart unless-stopped \
            #   -e NODE_ENV=production \
            #   -p 80:80 \
            #   "${{ secrets.DOCKER_USERNAME }}/dental-frontend:latest"

             sudo docker run -d --name backend \
              --restart unless-stopped \
              -e NODE_ENV=production \
              -e BACKEND_PORT=9000 \
              -e FRONT_END_PORT=80 \
              -e HOST="http://${{ secrets.EC2_PROD_01_HOST }}" \
              -e MONGO_URI="${{ secrets.MONGO_URI }}" \
              -e STRIPE_SECRET_KEY="${{ secrets.STRIPE_SECRET_KEY }}" \
              -p 9000:9000 \
              "${{ secrets.DOCKER_USERNAME }}/dental-backend:latest"

            # ----- run frontend (container listens on 8080; expose public 80) -----
            sudo docker run -d --name frontend \
              --restart unless-stopped \
              -e NODE_ENV=production \
              -e FRONT_END_PORT=80 \
              -e VITE_BACKEND_PORT="9000" \
              -e VITE_FRONTEND_URL="http://${{ secrets.EC2_PROD_01_HOST }}" \
              -e VITE_HOST="http://${{ secrets.EC2_PROD_01_HOST }}" \
              -p 80:8080 \
              "${{ secrets.DOCKER_USERNAME }}/dental-frontend:latest"


            # ----- health check -----
            sleep 3
            sudo docker ps

  deploy-ec2-prod-environment-b:
    name: Deploy New images to Production-b environment EC2 via SSH
    needs: [Run-rbt-Testing]
    runs-on: ubuntu-latest
    # allow committing the metrics CSV back to the repo
    permissions:
      contents: write

    steps:
      - name: Deploy over SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_PROD_B_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          port: 22
          script_stop: true
          envs: |
            DOCKER_USER,DOCKER_TOKEN,BACKEND_IMAGE,FRONTEND_IMAGE,MONGO_URI,STRIPE_SECRET_KEY
          command_timeout: 30m
          script: |
            # ----- pull newest images -----
            sudo docker pull "${{ secrets.DOCKER_USERNAME }}/dental-backend:latest"
            sudo docker pull "${{ secrets.DOCKER_USERNAME }}/dental-frontend:latest"

            # ----- stop & remove old containers -----
            sudo docker rm -f backend || true
            sudo docker rm -f frontend || true

            # # ----- run backend (port 9000) -----
            # sudo docker run -d --name backend \
            #   --restart unless-stopped \
            #   -e NODE_ENV=production \
            #   -e BACKEND_PORT=9000 \
            #   -e MONGO_URI="${{ secrets.MONGO_URI }}" \
            #   -e STRIPE_SECRET_KEY="${{ secrets.STRIPE_SECRET_KEY }}" \
            #   -p 9000:9000 \
            #   "${{ secrets.DOCKER_USERNAME }}/dental-backend:latest"

            # # ----- run frontend (container listens on 8080; expose public 80) -----
            # sudo docker run -d --name frontend \
            #   --restart unless-stopped \
            #   -e NODE_ENV=production \
            #   -p 80:8080 \
            #   "${{ secrets.DOCKER_USERNAME }}/dental-frontend:latest"

             sudo docker run -d --name backend \
              --restart unless-stopped \
              -e NODE_ENV=production \
              -e BACKEND_PORT=9000 \
              -e FRONT_END_PORT=80 \
              -e HOST="http://${{ secrets.EC2_PROD_B_HOST }}" \
              -e MONGO_URI="${{ secrets.MONGO_URI }}" \
              -e STRIPE_SECRET_KEY="${{ secrets.STRIPE_SECRET_KEY }}" \
              -p 9000:9000 \
              "${{ secrets.DOCKER_USERNAME }}/dental-backend:latest"

            # ----- run frontend (container listens on 8080; expose public 80) -----
            sudo docker run -d --name frontend \
              --restart unless-stopped \
              -e NODE_ENV=production \
              -e FRONT_END_PORT=80 \
              -e VITE_BACKEND_PORT="9000" \
              -e VITE_FRONTEND_URL="http://${{ secrets.EC2_PROD_B_HOST }}" \
              -e VITE_HOST="http://${{ secrets.EC2_PROD_B_HOST }}" \
              -p 80:80 \
              "${{ secrets.DOCKER_USERNAME }}/dental-frontend:latest"


            # ----- health check -----
            sleep 3
            sudo docker ps

   

    
